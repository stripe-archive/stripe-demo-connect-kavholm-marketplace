"use strict";var _mkdirp=_interopRequireDefault(require("mkdirp"));var _util=require("util");var _path=require("path");var _render=require("next-server/dist/server/render");var _fs=require("fs");var _asyncSema=require("async-sema");var _amphtmlValidator=_interopRequireDefault(require("amphtml-validator"));var _loadComponents=require("next-server/dist/server/load-components");var _isDynamic=require("next-server/dist/lib/router/utils/is-dynamic");var _routeMatcher=require("next-server/dist/lib/router/utils/route-matcher");var _routeRegex=require("next-server/dist/lib/router/utils/route-regex");function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const envConfig=require('next-server/config');const mkdirp=(0,_util.promisify)(_mkdirp.default);const writeFileP=(0,_util.promisify)(_fs.writeFile);const accessP=(0,_util.promisify)(_fs.access);global.__NEXT_DATA__={nextExport:true};process.on('message',async({distDir,buildId,exportPaths,exportPathMap,outDir,renderOpts,serverRuntimeConfig,concurrency,subFolders,serverless})=>{const sema=new _asyncSema.Sema(concurrency,{capacity:exportPaths.length});try{const work=async path=>{await sema.acquire();let{query={}}=exportPathMap[path];const{page,sprPage}=exportPathMap[path];const filePath=path==='/'?'/index':path;const ampPath=`${filePath}.amp`;// Check if the page is a specified dynamic route
if((0,_isDynamic.isDynamicRoute)(page)&&page!==path){const params=(0,_routeMatcher.getRouteMatcher)((0,_routeRegex.getRouteRegex)(page))(path);if(params){query={...query,...params};}else{throw new Error(`The provided export path '${path}' doesn't match the '${page}' page.\nRead more: https://err.sh/zeit/next.js/export-path-mismatch`);}}const headerMocks={headers:{},getHeader:()=>({}),setHeader:()=>{},hasHeader:()=>false,removeHeader:()=>{},getHeaderNames:()=>[]};const req={url:path,...headerMocks};const res={...headerMocks};if(sprPage&&(0,_isDynamic.isDynamicRoute)(page)){query._nextPreviewSkeleton=1;// pass via `req` to avoid adding code to serverless bundle
req.url+=(req.url.includes('?')?'&':'?')+'_nextPreviewSkeleton=1';}envConfig.setConfig({serverRuntimeConfig,publicRuntimeConfig:renderOpts.runtimeConfig});let htmlFilename=`${filePath}${_path.sep}index.html`;if(!subFolders)htmlFilename=`${filePath}.html`;const pageExt=(0,_path.extname)(page);const pathExt=(0,_path.extname)(path);// Make sure page isn't a folder with a dot in the name e.g. `v1.2`
if(pageExt!==pathExt&&pathExt!==''){// If the path has an extension, use that as the filename instead
htmlFilename=path;}else if(path==='/'){// If the path is the root, just use index.html
htmlFilename='index.html';}const baseDir=(0,_path.join)(outDir,(0,_path.dirname)(htmlFilename));const htmlFilepath=(0,_path.join)(outDir,htmlFilename);await mkdirp(baseDir);let html;let curRenderOpts={};let renderMethod=_render.renderToHTML;if(serverless){renderMethod=require((0,_path.join)(distDir,'serverless/pages',(page==='/'?'index':page)+'.js')).renderReqToHTML;const result=await renderMethod(req,res,true);curRenderOpts=result.renderOpts;html=result.html;}else{const components=await(0,_loadComponents.loadComponents)(distDir,buildId,page,serverless);if(typeof components.Component==='string'){html=components.Component;}else{curRenderOpts={...components,...renderOpts,ampPath};html=await renderMethod(req,res,page,query,curRenderOpts);}}const validateAmp=async(html,page)=>{const validator=await _amphtmlValidator.default.getInstance();const result=validator.validateString(html);const errors=result.errors.filter(e=>e.severity==='ERROR');const warnings=result.errors.filter(e=>e.severity!=='ERROR');if(warnings.length||errors.length){process.send({type:'amp-validation',payload:{page,result:{errors,warnings}}});}};if(curRenderOpts.inAmpMode){await validateAmp(html,path);}else if(curRenderOpts.hybridAmp){// we need to render the AMP version
let ampHtmlFilename=`${ampPath}${_path.sep}index.html`;if(!subFolders){ampHtmlFilename=`${ampPath}.html`;}const ampBaseDir=(0,_path.join)(outDir,(0,_path.dirname)(ampHtmlFilename));const ampHtmlFilepath=(0,_path.join)(outDir,ampHtmlFilename);try{await accessP(ampHtmlFilepath);}catch(_){// make sure it doesn't exist from manual mapping
let ampHtml;if(serverless){req.url+=(req.url.includes('?')?'&':'?')+'amp=1';ampHtml=(await renderMethod(req,res,true)).html;}else{ampHtml=await renderMethod(req,res,page,{...query,amp:1},curRenderOpts);}await validateAmp(ampHtml,page+'?amp=1');await mkdirp(ampBaseDir);await writeFileP(ampHtmlFilepath,ampHtml,'utf8');}}await writeFileP(htmlFilepath,html,'utf8');process.send({type:'progress'});sema.release();};await Promise.all(exportPaths.map(work));process.send({type:'done'});}catch(err){console.error(err);process.send({type:'error',payload:err});}});